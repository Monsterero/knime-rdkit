/* 
 * This source code, its documentation and all related files
 * are protected by copyright law. All rights reserved.
 *
 * Copyright (C) 2012
 * Novartis Institutes for BioMedical Research
 *
 * You may not modify, publish, transmit, transfer or sell, reproduce,
 * create derivative works from, distribute, perform, display, or in
 * any way exploit any of the content, in whole or in part, except as
 * otherwise expressly permitted in writing by the copyright owner or
 * as specified in the license file distributed with this product.
 */
package org.rdkit.knime.nodes;

import org.knime.core.data.DataTableSpec;
import org.knime.core.data.container.ColumnRearranger;
import org.knime.core.node.BufferedDataTable;
import org.knime.core.node.ExecutionContext;
import org.knime.core.node.InvalidSettingsException;
import org.knime.core.node.port.PortType;
import org.rdkit.knime.util.InputDataInfo;

/**
 * This class adds functionality common to a Calculator node. This is a node that 
 * adds normally additionally columns to an input table calculating their values
 * based on input columns.
 * 
 * @author Manuel Schwarze
 */
public abstract class AbstractRDKitCalculatorNodeModel extends
		AbstractRDKitNodeModel {
	
	//
	// Constructors
	//
	
	/**
	 * Creates a new node model with the specified number of input and output ports.
	 * 
	 * @param nrInDataPorts Number of input ports. Must be 0 .. n.
	 * @param nrOutDataPorts Number of output ports. Must be 0 .. m.
	 */
	protected AbstractRDKitCalculatorNodeModel(int nrInDataPorts,
			int nrOutDataPorts) {
		super(nrInDataPorts, nrOutDataPorts);
	}

	/**
	 * Creates a new node model with the specified input and output ports.
	 * 
	 * @param inPortTypes Input port definitions. Must not be null.
	 * @param outPortTypes  Output port definitions. Must not be null.
	 */
	protected AbstractRDKitCalculatorNodeModel(PortType[] inPortTypes,
			PortType[] outPortTypes) {
		super(inPortTypes, outPortTypes);
	}
    
	//
	// Protected Methods
	//
	
    /**
     * Returns the output table specification of the specified out port. This implementation
     * works based on a ColumnRearranger and delivers only a specification for
     * out port 0, based on an input table on in port 0. Override this method if
     * other behavior is needed.
     * 
     * @param outPort Index of output port in focus. Zero-based.
     * @param inSpecs All input table specifications.
     * 
     * @return The specification of all output tables.
     * 
     * @throws InvalidSettingsException Thrown, if the settings are inconsistent with 
     * 		given DataTableSpec elements.
     * 
     * @see #createOutputFactories(int)
     */
    protected DataTableSpec getOutputTableSpec(final int outPort, 
    		final DataTableSpec[] inSpecs) throws InvalidSettingsException {
    	DataTableSpec spec = null;
    	
    	if (outPort == 0) {
	    	// Create the column rearranger, which will generate the spec
	        spec = createColumnRearranger(0, inSpecs[0]).createSpec();
    	}
    	
    	return spec;
    }
	
	/**
	 * This method needs to be implemented by a concrete node to generate cell factories
	 * for all output tables. As there can be more than one factory specified to generate
	 * cells for a table, it returns for one output port an array of factories. However,
	 * usually only one element will be contained in this array. 
	 * 
	 * @param outPort The port number of the output table to create factories for.
	 * @param inSpec Specification of the table to be merged with new columns that
	 * 		will be generated by the factories. Can be null.
 	 * 
	 * @return An array of factory objects. Should not return null. If no factories 
	 * 		are used, it should return an empty array.
	 * 
	 * @throws InvalidSettingsException Thrown, if creation of output factories fails.
	 */
	protected abstract AbstractRDKitCellFactory[] createOutputFactories(int outPort, DataTableSpec inSpec)
		throws InvalidSettingsException;

    /**
     * Creates a column rearranger based on all cell factories that are delivered
     * by a call to {@link #createOutputFactories(int)}). These factories (usually
     * there is just one) implement the logic to calculate new cells based on the input
     * defined by the input data info objects delivered by a call to
     * {@link #createInputDataInfos(DataTableSpec[])}.
     * 
     * @param outPort The output port of the node the column rearranger shall be created for. This
     * 		value is used to create the output factories - a call is made to
     * 		{@link #createOutputFactories(int)} with this outPort id.
     * @param inSpec The specification of the table the result column rearranger shall
     * 		be based on. Must not be null.
     * 
     * @return Column Rearranger for the specified input table.
     * 
     * @throws InvalidSettingsException Thrown, if invalid settings are encountered while creating
     * 		and gathering all necessary information in order to create the column rearranger object.
     */
    protected ColumnRearranger createColumnRearranger(final int outPort, DataTableSpec inSpec) throws InvalidSettingsException {
        
    	if (inSpec == null) {
    		throw new IllegalArgumentException("No input table specification available.");
    	}
    	
    	// Create column rearranger
    	InputDataInfo[] arrInputDataInfo = createInputDataInfos(0, inSpec);
        ColumnRearranger result = new ColumnRearranger(inSpec);
        AbstractRDKitCellFactory[] arrOutputFactories = createOutputFactories(outPort, inSpec);
        for (AbstractRDKitCellFactory factory : arrOutputFactories) {
        	factory.setInputDataInfos(arrInputDataInfo);
        	result.append(factory);
        }
        
        return result;
    }
    
    /**
     * {@inheritDoc}
     */
    @Override
    protected BufferedDataTable[] processing(final BufferedDataTable[] inData, InputDataInfo[][] arrInputDataInfo,
    		final ExecutionContext exec) throws Exception {
    	// Generate column rearranger, which will do the work for us
        ColumnRearranger rearranger = createColumnRearranger(0, inData[0].getDataTableSpec());
         
        // Generate the output table and return it.
        return new BufferedDataTable[] { exec.createColumnRearrangeTable(inData[0], rearranger, exec) };
    }
}
